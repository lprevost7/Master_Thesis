#!/bin/bash
###############################################################################
# This script is the command that is executed every run.
# Check the examples in examples/
#
# This script is run in the execution directory (execDir, --exec-dir).
#
# PARAMETERS:
# $1 is the candidate configuration number
# $2 is the instance ID
# $3 is the seed
# $4 is the instance name
# The rest ($* after `shift 4') are parameters to the run
#
# RETURN VALUE:
# This script should print one numerical value: the cost that must be minimized.
# Exit with 0 if no error, with 1 in case of error
###############################################################################
## Find our own location.
# BINDIR=$(dirname "$(readlink -f "$(type -P $0 || echo $0)")")

# Path to the compiled solver (relative to this script location)
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
EXE="${SCRIPT_DIR}/../../../build/emili"
PROBLEM="PFSP_MS"

error() {
    echo "`TZ=UTC date`: $0: error: $@"
    exit 1
}

# This parses the arguments given by irace. Do not touch it!
CONFIG_ID=$1
INSTANCE_ID=$2
SEED=$3
INSTANCE=$4
shift 4 || error "Not enough parameters"
CONFIG_PARAMS=$*
# End of parsing

# A safer tmp prefix per run (needs parsed IDs)
RUN_TAG="c${CONFIG_ID}-${INSTANCE_ID}-${SEED}"
STDOUT="${RUN_TAG}.stdout"
STDERR="${RUN_TAG}.stderr"

if [ ! -x "${EXE}" ]; then
    error "${EXE}: not found or not executable (pwd: $(pwd))"
fi

# # If the program just prints a number, we can use 'exec' to avoid creating
# # another process, but there can be no other commands after exec, only exit.
# exec $EXE ${EXE_PARAMS}
# exit 1

# Parse key/value pairs coming from irace.
# IMPORTANT: In parameters.txt, option names are like "--initial_solution".
# Internally, this script uses keys without the leading "--".
ALG=""
declare -A P

set -- ${CONFIG_PARAMS}
while [ $# -gt 0 ]; do
    case "$1" in
        --algorithm)
            ALG="$2";
            P[algorithm]="$2";
            shift 2
            ;;
        --*)
            key="${1#--}"
            val="$2"
            P["$key"]="$val"
            shift 2
            ;;
        *)
            error "Unexpected token from irace: '$1' (expected --key value pairs)"
            ;;
    esac
done

if [ -z "${ALG}" ]; then
    error "algorithm not specified"
fi

# Helpers ---------------------------------------------------------------
initial_tokens() {
    local init="${P[initial_solution]}"
    case "$init" in
        irandom) echo "irandom ${P[irandom_k]}" ;;
        lr)      echo "lr ${P[lr_size]}" ;;
        nlr)     echo "nlr ${P[nlr_size]}" ;;
        ff)      echo "ff ${P[ff_a]} ${P[ff_b]} ${P[ff_k]}" ;;
        ffn)     echo "ffn ${P[ff_a]} ${P[ff_b]}" ;;
        bsch)    echo "bsch ${P[bsch_a]}" ;;
        bscho)   echo "bscho ${P[bscho_a]} ${P[bscho_b]} ${P[bscho_c]} ${P[bscho_k]}" ;;
        bschr)   echo "bschr ${P[bschr_a]} ${P[bschr_b]} ${P[bschr_c]} ${P[bschr_d]}" ;;
        bs)      echo "bs ${P[bs_a]} ${P[bs_b]} ${P[bs_c]} ${P[bs_d]} ${P[bs_k1]}" ;;
        bs2)     echo "bs2 ${P[bs2_a]} ${P[bs2_b]} ${P[bs2_c]} ${P[bs2_e]} ${P[bs2_gamma]}" ;;
        bs2n)    echo "bs2n ${P[bs2n_a]} ${P[bs2n_b]} ${P[bs2n_c]} ${P[bs2n_e]} ${P[bs2n_frac]}" ;;
        bsnn)    echo "bsnn ${P[bsnn_a]} ${P[bsnn_b]} ${P[bsnn_c]} ${P[bsnn_e]}" ;;
        *)       echo "$init" ;;
    esac
}


termination_tokens() {
    local t="${P[termination]}"
    case "$t" in
        true|locmin) echo "$t";;
        time|timero) echo "$t ${P[time_value]}";;
        maxstep)     echo "maxstep ${P[maxstep_value]}";;
        msorlocmin)  echo "msorlocmin ${P[msorlocmin_value]}";;
        msnoimp)     echo "msnoimp ${P[msnoimp_value]}";;
        *)           echo "";;
    esac
}


perturbation_tokens() {
    # Usage:
    #   perturbation_tokens <ptype> <moves_key> <rndmv_neigh_key> <rndmv_moves_key>
    local ptype="$1"
    local moves_key="$2"
    local rndmv_neigh_key="$3"
    local rndmv_moves_key="$4"

    case "$ptype" in
        igper|noper|nrzper|tmiigper|nwtmiigper)
            echo "$ptype ${P[$moves_key]}" ;;
        rndmv)
            echo "rndmv ${P[$rndmv_neigh_key]} ${P[$rndmv_moves_key]}" ;;
        mptlm|restart|restartls|sdstigo|sdstigols|testper)
            echo "$ptype" ;;
        *) echo "" ;;
    esac
}

acceptance_tokens() {
    local atype="${P[acceptance]}"
    case "$atype" in
        metropolis)      echo "metropolis ${P[acc_temp]}" ;;
        always)          echo "always ${P[acc_always_mode]}" ;;
        improve)         echo "improve" ;;
        sa_metropolis)   echo "sa_metropolis ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]}" ;;
        pmetro)          echo "pmetro ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]} ${P[acc_iter]}" ;;
        saacc)           echo "saacc ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]} ${P[acc_sa_iter]} ${P[acc_alpha]}" ;;
        implat)          echo "implat ${P[implat_nonimp]} ${P[implat_plateau]}" ;;
        explore)         echo "explore ${P[acc_explore_steps]}" ;;
        *)               echo "" ;;
    esac
}

neigh_tokens() {
    local slot="$1"   # neigh1 | neigh2 | neigh3
    local n="$2"

    case "$n" in
        none|"")
            echo ""
            ;;
        tatxinsert)
            case "$slot" in
                neigh1) echo "tatxinsert ${P[tatx_a]}" ;;
                neigh2) echo "tatxinsert ${P[tatx2_a]}" ;;
                neigh3) echo "tatxinsert ${P[tatx3_a]}" ;;
                *)      echo "tatxinsert ${P[tatx_a]}" ;;
            esac
            ;;
        *)
            echo "$n"
            ;;
    esac
}


ils_pert_tokens() {
    local p="${P[ils_perturbation]}"
    case "$p" in
        ""|noper)
            echo "noper"
            ;;
        rndmv)
            echo "rndmv ${P[ils_per_rndmv_neigh]} ${P[ils_per_rndmv_moves]}"
            ;;
        *)
            # safe fallback
            echo "noper"
            ;;
    esac
}
vns_pert_tokens() {
    # arg: 1 or 2 selects vns perturbation slot
    local slot="$1"
    local ptype_key="vns_perturbation${slot}"
    local rnd_neigh_key="vns_p${slot}_rndmv_neigh"
    local rnd_moves_key="vns_p${slot}_rndmv_moves"

    local ptype="${P[$ptype_key]}"
    case "$ptype" in
        ""|none)
            echo ""
            ;;
        noper)
            echo "noper"
            ;;
        rndmv)
            echo "rndmv ${P[$rnd_neigh_key]} ${P[$rnd_moves_key]}"
            ;;
        *)
            # unsupported token -> emit nothing (or default noper)
            echo ""
            ;;
    esac
}



# Build command per algorithm ------------------------------------------
CMD=("${EXE}" "${INSTANCE}" "${PROBLEM}")

# Utility to append a space-separated token string as real argv entries
append_tokens() {
    local s="$1"
    [ -z "$s" ] && return 0
    local -a toks
    # shellcheck disable=SC2206
    toks=($s)
    CMD+=("${toks[@]}")
}

case "$ALG" in
    ch6)
        CMD+=("ch6")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens neigh1 "${P[neigh1]}")"
        append_tokens "$(neigh_tokens neigh2 "${P[neigh2]}")"

        ;;
    ris)
        CMD+=("ris")
        append_tokens "$(initial_tokens)"
        ;;
    tabu)
        CMD+=("tabu" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"
        CMD+=("${P[tabu_memory]}")
        if [ -n "${P[tabu_memory_size]}" ]; then CMD+=("${P[tabu_memory_size]}"); fi
        ;;
    vnd)
        CMD+=("vnd" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"
        append_tokens "$(neigh_tokens "${P[neigh2]}")"
        append_tokens "$(neigh_tokens "${P[neigh3]}")"
        [ -n "$n1" ] && CMD+=("$n1")
        [ -n "$n2" ] && CMD+=("$n2")
        [ -n "$n3" ] && CMD+=("$n3")
        ;;
    vns)
        # VNS expects:
        # vns <ALGORITHM_SPEC> <TERMINATION_SPEC> <SHAKE_SPEC> <NEIGHBORHOOD_CHANGE_SPEC>
        # where ALGORITHM_SPEC can be: first|best <initial> <termination> <neighborhood>

        CMD+=("vns" "${P[vns_ls_mode]:-${P[ls_mode]:-first}}")

        # ---- inner local search algorithm spec ----
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"

        # ---- outer termination ----
        append_tokens "$(termination_tokens)"

        # ---- shake ----
        if [ "${P[vns_shake]}" = "nshake" ]; then
            # nshake <neighborhood>... <Kmax(int)>
            CMD+=("nshake")
            append_tokens "$(neigh_tokens "${P[vns_nshake_neigh1]:-${P[neigh1]}}")"
            if [ -n "${P[vns_nshake_neigh2]}" ] && [ "${P[vns_nshake_neigh2]}" != "none" ]; then
                append_tokens "$(neigh_tokens "${P[vns_nshake_neigh2]}")"
            fi
            CMD+=("${P[vns_nshake_k]}")
        else
            # pershake <perturbation> <perturbation> ...
            CMD+=("pershake")
            p1="$(vns_pert_tokens 1)"
            p2="$(vns_pert_tokens 2)"
            [ -n "$p1" ] && append_tokens "$p1"
            [ -n "$p2" ] && append_tokens "$p2"
            # safety: must have at least one perturbation
            if [ -z "$p1" ] && [ -z "$p2" ]; then
                CMD+=("noper")
            fi
        fi

        # ---- neighborhood change ----
        CMD+=("accng")
        acc="$(acceptance_tokens)"
        if [ -z "$acc" ]; then
        acc="improve"   # safe default (no parameters)
        fi
        append_tokens "$acc"
        ;;

    ils)
        # ils <(first|best ...)> <outer_term> <perturbation> <acceptance>

        # Inner local search algorithm spec:
        # (first|best) <initial> <inner_term> <neighborhood>
        CMD+=("ils" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"

        # Outer termination
        append_tokens "$(termination_tokens)"

        # Perturbation: must never be empty
        append_tokens "$(ils_pert_tokens)"

        # Acceptance: must never be empty either (put a safe fallback in acceptance_tokens if needed)
        append_tokens "$(acceptance_tokens)"
        ;;

    *)
        error "unsupported algorithm ${ALG}"
        ;;
esac

# Uncomment to debug command lines
#echo "Running: ${CMD[*]}" >&2

# Print the command line to stdout file
echo "Running: ${CMD[*]}" >> "${STDOUT}"

#"${CMD[@]}" 1>>"${STDOUT}" 2>"${STDERR}" || error "solver failed"

if [ ! -s "${STDOUT}" ]; then
    error "${STDOUT}: No such file or directory"
fi

# Parse cost: last numeric field of the last line containing "Objective function value"
COST=$(grep -i "Objective function value" "${STDOUT}" | awk '{print $NF}' | tail -n 1)

# Fallback: last numeric-looking token in output
if [ -z "${COST}" ]; then
    COST=$(grep -Eo '[0-9]+(\.[0-9]+)?' "${STDOUT}" | tail -n 1)
fi

if [ -z "${COST}" ]; then
    error "Could not parse objective value from output"
fi

echo "${COST}"

# Comment the following line if you wish to preserve temporary files (e.g., for debugging)
rm -f "${STDOUT}" "${STDERR}"
exit 0
