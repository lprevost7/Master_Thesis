#!/bin/bash
###############################################################################
# This script is the command that is executed every run.
# Check the examples in examples/
#
# This script is run in the execution directory (execDir, --exec-dir).
#
# PARAMETERS:
# $1 is the candidate configuration number
# $2 is the instance ID
# $3 is the seed
# $4 is the instance name
# The rest ($* after `shift 4') are parameters to the run
#
# RETURN VALUE:
# This script should print one numerical value: the cost that must be minimized.
# Exit with 0 if no error, with 1 in case of error
###############################################################################
## Find our own location.
# BINDIR=$(dirname "$(readlink -f "$(type -P $0 || echo $0)")")

# Path to the compiled solver (relative to this script location)
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
EXE="${SCRIPT_DIR}/../../../build/emili"
PROBLEM="PFSP_MS"

error() {
    echo "`TZ=UTC date`: $0: error: $@"
    exit 1
}

# This parses the arguments given by irace. Do not touch it!
CONFIG_ID=$1
INSTANCE_ID=$2
SEED=$3
INSTANCE=$4
shift 4 || error "Not enough parameters"
CONFIG_PARAMS=$*
# End of parsing

# A safer tmp prefix per run (needs parsed IDs)
RUN_TAG="c${CONFIG_ID}-${INSTANCE_ID}-${SEED}"
STDOUT="${RUN_TAG}.stdout"
STDERR="${RUN_TAG}.stderr"

if [ ! -x "${EXE}" ]; then
    error "${EXE}: not found or not executable (pwd: $(pwd))"
fi

# # If the program just prints a number, we can use 'exec' to avoid creating
# # another process, but there can be no other commands after exec, only exit.
# exec $EXE ${EXE_PARAMS}
# exit 1

# Parse key/value pairs coming from irace.
# IMPORTANT: In parameters.txt, option names are like "--initial_solution".
# Internally, this script uses keys without the leading "--".
ALG=""
declare -A P

set -- ${CONFIG_PARAMS}
while [ $# -gt 0 ]; do
    case "$1" in
        --algorithm)
            ALG="$2";
            P[algorithm]="$2";
            shift 2
            ;;
        --*)
            key="${1#--}"
            val="$2"
            P["$key"]="$val"
            shift 2
            ;;
        *)
            error "Unexpected token from irace: '$1' (expected --key value pairs)"
            ;;
    esac
done

if [ -z "${ALG}" ]; then
    error "algorithm not specified"
fi

# Helpers ---------------------------------------------------------------
initial_tokens() {
    local init="${P[initial_solution]}"
    case "$init" in
        irandom) echo "irandom ${P[irandom_k]}" ;;
        lr)      echo "lr ${P[lr_size]}" ;;
        nlr)     echo "nlr ${P[nlr_size]}" ;;
        ff)      echo "ff ${P[ff_a]} ${P[ff_b]} ${P[ff_k]}" ;;
        ffn)     echo "ffn ${P[ff_a]} ${P[ff_b]}" ;;
        bschr)   echo "bschr ${P[bschr_a]} ${P[bschr_b]} ${P[bschr_c]} ${P[bschr_d]}" ;;
        bs2)     echo "bs2 ${P[bs2_a]} ${P[bs2_b]} ${P[bs2_c]} ${P[bs2_e]} ${P[bs2_gamma]}" ;;
        bs2n)    echo "bs2n ${P[bs2n_a]} ${P[bs2n_b]} ${P[bs2n_c]} ${P[bs2n_e]} ${P[bs2n_frac]}" ;;
        bsnn)    echo "bsnn ${P[bsnn_a]} ${P[bsnn_b]} ${P[bsnn_c]} ${P[bsnn_e]}" ;;
        *)       echo "$init" ;;
    esac
}


termination_tokens() {
    local t="${P[termination]}"
    case "$t" in
        true|locmin) echo "$t";;
        time|timero) echo "$t ${P[time_value]}";;
        maxstep)     echo "maxstep ${P[maxstep_value]}";;
        msorlocmin)  echo "msorlocmin ${P[msorlocmin_value]}";;
        msnoimp)     echo "msnoimp ${P[msnoimp_value]}";;
        *)           echo "";;
    esac
}


perturbation_tokens() {
    # Usage:
    #   perturbation_tokens <ptype> <moves_key> <rndmv_neigh_key> <rndmv_moves_key>
    local ptype="$1"
    local moves_key="$2"
    local rndmv_neigh_key="$3"
    local rndmv_moves_key="$4"

    case "$ptype" in
        igper|noper|nrzper|tmiigper|nwtmiigper)
            echo "$ptype ${P[$moves_key]}" ;;
        rndmv)
            echo "rndmv ${P[$rndmv_neigh_key]} ${P[$rndmv_moves_key]}" ;;
        mptlm|restart|restartls|sdstigo|sdstigols|testper)
            echo "$ptype" ;;
        *) echo "" ;;
    esac
}

acceptance_tokens() {
    local atype="${P[acceptance]}"
    case "$atype" in
        metropolis)      echo "metropolis ${P[acc_temp]}" ;;
        always)          echo "always ${P[acc_always_mode]}" ;;
        improve)         echo "improve" ;;
        sa_metropolis)   echo "sa_metropolis ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]}" ;;
        pmetro)          echo "pmetro ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]} ${P[acc_iter]}" ;;
        saacc)           echo "saacc ${P[acc_start]} ${P[acc_end]} ${P[acc_ratio]} ${P[acc_sa_iter]} ${P[acc_alpha]}" ;;
        implat)          echo "implat ${P[implat_nonimp]} ${P[implat_plateau]}" ;;
        prob)            echo "prob ${P[acc_prob]}" ;;
        explore)         echo "explore" ;;
        *)               echo "" ;;
    esac
}

neigh_tokens() {
    local n="$1"

    case "$n" in
        none|"")
            echo ""
            ;;
        tatxinsert)
            echo "tatxinsert ${P[tatx_a]} ${P[tatx_b]}"
            ;;
        *)
            # Default: atomic neighborhood
            echo "$n"
            ;;
    esac
}

ils_pert_tokens() {
    local p="${P[ils_perturbation]}"
    case "$p" in
        ""|noper)
            echo "noper"
            ;;
        rndmv)
            echo "rndmv ${P[ils_per_rndmv_neigh]} ${P[ils_per_rndmv_moves]}"
            ;;
        *)
            # safe fallback
            echo "noper"
            ;;
    esac
}


# Build command per algorithm ------------------------------------------
CMD=("${EXE}" "${INSTANCE}" "${PROBLEM}")

# Utility to append a space-separated token string as real argv entries
append_tokens() {
    local s="$1"
    [ -z "$s" ] && return 0
    local -a toks
    # shellcheck disable=SC2206
    toks=($s)
    CMD+=("${toks[@]}")
}

case "$ALG" in
    ch6)
        CMD+=("ch6")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"
        append_tokens "$(neigh_tokens "${P[neigh2]}")"
        ;;
    ris)
        CMD+=("ris")
        append_tokens "$(initial_tokens)"
        ;;
    tabu)
        CMD+=("tabu" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"
        CMD+=("${P[tabu_memory]}")
        if [ -n "${P[tabu_memory_size]}" ]; then CMD+=("${P[tabu_memory_size]}"); fi
        ;;
    vnd)
        CMD+=("vnd" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"
        append_tokens "$(neigh_tokens "${P[neigh2]}")"
        append_tokens "$(neigh_tokens "${P[neigh3]}")"
        [ -n "$n1" ] && CMD+=("$n1")
        [ -n "$n2" ] && CMD+=("$n2")
        [ -n "$n3" ] && CMD+=("$n3")
        ;;
    vns)
        # VNS expects: vns <algorithm> <termination> <shake> <neigh_change>
        ls_token="${P[vns_ls_mode]:-first}"
        p1=$(perturbation_tokens "${P[vns_perturbation1]}" "vns_p1_moves" "vns_p1_rndmv_neigh" "vns_p1_rndmv_moves")
        p2=$(perturbation_tokens "${P[vns_perturbation2]}" "vns_p2_moves" "vns_p2_rndmv_neigh" "vns_p2_rndmv_moves")

        # Build shake component
        shake_tok="pershake"
        shake_payload=()
        if [ "${P[vns_shake]}" = "nshake" ]; then
            shake_tok="nshake"
            # use provided neighborhoods (fallback to neigh1/neigh2) and a max size
            shake_payload+=("${P[neigh1]}")
            [ -n "${P[neigh2]}" ] && shake_payload+=("${P[neigh2]}")
            shake_payload+=("${P[vns_nshake_k]:-1}")
        else
            # pershake with up to two perturbations
            [ -n "$p1" ] && shake_payload+=($p1)
            [ -n "$p2" ] && shake_payload+=($p2)
            # default safe perturbation if none provided
            if [ ${#shake_payload[@]} -eq 0 ]; then
                shake_payload+=("noper")
            fi
        fi

        CMD+=("vns" "$ls_token")
        append_tokens "$(termination_tokens)"
        CMD+=("$shake_tok")
        CMD+=("${shake_payload[@]}")
        CMD+=("accng")
        ;;
    ils)
        # ils <(first|best ...)> <outer_term> <perturbation> <acceptance>

        # Inner local search algorithm spec:
        # (first|best) <initial> <inner_term> <neighborhood>
        CMD+=("ils" "${P[ls_mode]}")
        append_tokens "$(initial_tokens)"
        append_tokens "$(termination_tokens)"
        append_tokens "$(neigh_tokens "${P[neigh1]}")"

        # Outer termination
        append_tokens "$(termination_tokens)"

        # Perturbation: must never be empty
        append_tokens "$(ils_pert_tokens)"

        # Acceptance: must never be empty either (put a safe fallback in acceptance_tokens if needed)
        append_tokens "$(acceptance_tokens)"
        ;;

    *)
        error "unsupported algorithm ${ALG}"
        ;;
esac

# Uncomment to debug command lines
#echo "Running: ${CMD[*]}" >&2

# Print the command line to stdout file
echo "Running: ${CMD[*]}" >> "${STDOUT}"

"${CMD[@]}" 1>>"${STDOUT}" 2>"${STDERR}" || error "solver failed"

if [ ! -s "${STDOUT}" ]; then
    error "${STDOUT}: No such file or directory"
fi

# Parse cost: last numeric field of the last line containing "Objective function value"
COST=$(grep -i "Objective function value" "${STDOUT}" | awk '{print $NF}' | tail -n 1)

# Fallback: last numeric-looking token in output
if [ -z "${COST}" ]; then
    COST=$(grep -Eo '[0-9]+(\.[0-9]+)?' "${STDOUT}" | tail -n 1)
fi

if [ -z "${COST}" ]; then
    error "Could not parse objective value from output"
fi

echo "${COST}"

# Comment the following line if you wish to preserve temporary files (e.g., for debugging)
rm -f "${STDOUT}" "${STDERR}"
exit 0
